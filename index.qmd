---
title: "Towards compositional epidemiological modelling"
author:
  - name: "Samuel P. C. Brand"
    affiliation: "Center for Forecasting and Outbreak Analysis; Centers for Disease Control"
    email: "usi1@cdc.gov"
    orcid: "0000-0003-0645-5367"
  - name: "Samuel Abbott"
    affiliation: "Centre for Mathematical Modelling of Infectious Diseases, London School of Hygiene & Tropical Medicine"
    email: "sam.abbott@lshtm.ac.uk" 
    orcid: "0000-0001-8057-8037"
date: today
abstract: |
  This paper presents a compositional approach to epidemiological modelling that enables "swap-in/swap-out" modelling decisions. We demonstrate the flexibility and power of this paradigm through three case studies that recreate existing infectious disease models using compositional components, showing how this design facilitates model comparison, validation, and methodological transparency in epidemiological research.
format:
  pdf:
    documentclass: article
    geometry: margin=1in
    fontsize: 11pt
    linestretch: 1.5
    keep-tex: false
    number-sections: false
    colorlinks: true
  html:
    toc: true
    number-sections: true
    embed-resources: true
bibliography: references.bib
csl: https://www.zotero.org/styles/plos-computational-biology
execute:
  echo: false
  warning: false
  cache: true
julia: 
  exeflags: ["+1.11.6", "--threads=8", "-O3"]
---

# Introduction {#sec-introduction}

- Introduce current common uses and limitations of epidemiological modelling in outbreak response and routine real-time surveillance.

## Current limitations in epidemiological modelling

- More specific details on limitations e.g. 
    - Monolithic model construction
    - Tight coupling between different model components,inference methods and implementation
    - Limited reusability and adaptability

- More specific details on problems this causes e.g.
    - Limited reusability, adaptability and retrospective evaluation.
        - Hard to isolate effect of specific modelling choices without large reimplementation.
        - Hard to introduce new/latest methods without large reimplementation.
    - Induces "Pipeline" approach where different models pass information rather than joint modelling.
        - Reduced transparency and reproducibility.
        - Complex implementations over many different models creates high barrier to entry.
    - Particularly problematic during outbreak response when inevitably there are new data sources.

# Compositional Epidemiological Modelling Approach {#sec-approach}

## Core design principles

- Outline/explain our compositional modelling paradigm e.g:
    - Core design principles
    - Complex epi models into a composition of modular reusable model components.
- Describe the core Latent vs Observation model split.
  - Describe a selection of submodels under this split.
- How this has become possible:
    - Advances in probabilistic programming (e.g. Turing)
    - Leveraging multiple dispatch e.g. structs in structs from Julia.

**Figure 1**: Schematic panel example. Based on talk to Turing.
  - A: Generic pattern. Branching structure of top level struct with args and modifying models demonstrating recursive dispatch.
  - B: Example: Building ARIMA as stack: `MA` -> `AR` -> `DiffLatentModel`
  - C: Example: Building Day of the week as stack: `TransformLatent` -> `BroadcastLatentModel` -> `Ascertainment`

## Contributions of this work

- Theoretical framework: Introduce the idea of combining epi models as input-output layers/submodels which are standalone models themselves (or descibed in a different way).
- Practical implementation: Talk about `EpiAware` struct in struct with method dispatch.
- Discuss layer/submodel modifiers in two contexts: 
    1. Extra details e.g. population structure
    2. Modelling refinements e.g. Day of week effects within a observation model
- Discuss passing the composed model to Pathfinder + Turing for inference.
- Quick overview of concrete case studies (unless this gets repetitive)

# Case Studies {#sec-case-studies}

## Example 1: Recreating Mishra et al. with compositional demonstration {#sec-example1}

<!-- Reference: https://arxiv.org/abs/2006.16487 -->
<!-- Implementation: https://cdcgov.github.io/Rt-without-renewal/stable/showcase/replications/mishra-2020/ -->

This example demonstrates the compositional approach by reconstructing the main results of @mishra2020covid for early COVID-19 in South Korea. The model is built from modular components:

- **Latent process**: AR(2) for time-varying $R_t$
- **Renewal model**: Generates latent infections from $R_t$ and a discretized serial interval
- **Observation model**: Negative binomial for observed cases

Below, we show only the essential code for constructing and fitting the model. Plotting and file-saving code is omitted for clarity. The full workflow is available in `examples/example1/example-1.qmd`.

### Load dependencies and data

```{julia}
using EpiAware, Turing, Distributions, CSV, DataFramesMeta, CairoMakie, Dates, Random, ReverseDiff
Random.seed!(1)
data_path = joinpath(@__DIR__, "examples/example1/south_korea_data.csv")
data = CSV.File(data_path) |> DataFrame
```

### Specify model components

```{julia}
# Latent AR(2) process for R_t
ar = AR(
  damp_priors = [truncated(Normal(0.1, 0.05), 0, 1), truncated(Normal(0.8, 0.05), 0, 1)],
  init_priors = [Normal(-1.0, 0.1), Normal(-1.0, 0.5)],
  Ïµ_t = HierarchicalNormal(std_prior = HalfNormal(0.5))
)

# Discretized serial interval
truth_GI = Gamma(6.5, 0.62)
model_data = EpiData(gen_distribution = truth_GI)

# Renewal infection model
log_I0_prior = Normal(log(1.0), 1.0)
epi = Renewal(model_data; initialisation_prior = log_I0_prior)

# Negative binomial observation model
obs = NegativeBinomialError(cluster_factor_prior = HalfNormal(0.1))
```

### Compose the full model and prepare data

```{julia}
epi_prob = EpiProblem(
  epi_model = epi,
  latent_model = ar,
  observation_model = obs,
  tspan = (45, 80)
)
fixed_cluster_factor = 0.25
south_korea_data = (
  y_t = data.cases_new[epi_prob.tspan[1]:epi_prob.tspan[2]],
  dates = data.date[epi_prob.tspan[1]:epi_prob.tspan[2]]
)
```

### Run inference

```{julia}
num_threads = min(10, Threads.nthreads())
function run_example1_inference(; num_threads = num_threads, data_to_fit = south_korea_data, epi_prob = epi_prob, fixed_cluster_factor = fixed_cluster_factor)
  inference_method = EpiMethod(
    pre_sampler_steps = [ManyPathfinder(nruns = 4, maxiters = 100)],
    sampler = NUTSampler(
      adtype = AutoReverseDiff(compile = true),
      ndraws = 2000,
      nchains = num_threads,
      mcmc_parallel = MCMCThreads(),
      nadapts = 500)
  )
  mdl = generate_epiaware(epi_prob, data_to_fit) |
      (var"obs.cluster_factor" = fixed_cluster_factor,)
  inference_results = apply_method(mdl, inference_method, data_to_fit)
  return inference_results
end
inference_results = run_example1_inference()
```

### Generate combined results figure


Below are the plotting functions required to generate the combined figure. These are adapted from the full example for standalone use.

```{julia}
# Helper to compute quantiles for generated quantities
function generated_quantiles(gens, quantity, qs; transformation = x -> x)
  mapreduce(hcat, gens) do gen
    getfield(gen, quantity) |> transformation
  end |> mat -> mapreduce(hcat, qs) do q
    map(eachrow(mat)) do row
      if any(ismissing, row)
        return missing
      else
        quantile(row, q)
      end
    end
  end
end

# Combined figure for Example 1
function figure2(inference_results; epi_prob = epi_prob, data_to_fit = south_korea_data,
    fixed_cluster_factor = fixed_cluster_factor, qs = [0.025, 0.25, 0.5, 0.75, 0.975])
  C = data_to_fit.y_t
  D = data_to_fit.dates

  # Case unconditional model for posterior predictive sampling
  mdl_unconditional = generate_epiaware(epi_prob,
    (y_t = fill(missing, length(C)),)
  ) | (var"obs.cluster_factor" = fixed_cluster_factor,)
  posterior_gens = generated_quantities(mdl_unconditional, inference_results.samples)

  # Prediction quantiles
  predicted_y_t = generated_quantiles(posterior_gens, :generated_y_t, qs)
  predicted_R_t = generated_quantiles(
    posterior_gens, :Z_t, qs; transformation = x -> exp.(x))

  ts = D .|> d -> d - minimum(D) .|> d -> d.value + 1
  t_ticks = string.(D)

  fig = Figure(size = (400, 800))
  ax1 = Axis(fig[1, 1];
    ylabel = "Daily cases",
    xticks = (ts[1:14:end], t_ticks[1:14:end]),
    title = "Posterior predictive: Cases"
  )
  ax2 = Axis(fig[2, 1];
    yscale = log10,
    title = "Prediction: Reproduction number",
    xticks = (ts[1:14:end], t_ticks[1:14:end])
  )
  linkxaxes!(ax1, ax2)

  lines!(ax1, ts, predicted_y_t[:, 3];
    color = :purple,
    linewidth = 2,
    label = "Post. median"
  )
  band!(ax1, 1:size(predicted_y_t, 1), predicted_y_t[:, 2], predicted_y_t[:, 4];
    color = (:purple, 0.4),
    label = "50%"
  )
  band!(ax1, 1:size(predicted_y_t, 1), predicted_y_t[:, 1], predicted_y_t[:, 5];
    color = (:purple, 0.2),
    label = "95%"
  )
  scatter!(ax1, C;
    color = :black,
    label = "Actual cases")
  axislegend(ax1)

  lines!(ax2, ts, predicted_R_t[:, 3];
    color = :green,
    linewidth = 2,
    label = "Post. median"
  )
  band!(ax2, 1:size(predicted_R_t, 1), predicted_R_t[:, 2], predicted_R_t[:, 4];
    color = (:green, 0.4),
    label = "50%"
  )
  band!(ax2, 1:size(predicted_R_t, 1), predicted_R_t[:, 1], predicted_R_t[:, 5];
    color = (:green, 0.2),
    label = "95%"
  )
  axislegend(ax2)

  ax3 = Axis(fig[3, 1];
    xticks = 0:14,
    xlabel = "Days",
    title = "Continuous and discrete generation intervals"
  )
  barplot!(ax3, model_data.gen_int;
    label = "Discretized next gen pmf"
  )
  lines!(truth_GI;
    label = "Continuous serial interval",
    color = :green
  )
  axislegend(ax3)

  fig
end
```

The code below produces a single figure with three panels: (A) Posterior predictive: Cases, (B) Posterior predictive: $R_t$, (C) Discretised serial interval pmf.

```{julia}
fig2_example1 = figure2(inference_results)
fig2_example1
```

![Posterior predictive results for South Korea COVID-19 case data. Top panel shows observed daily cases (black dots) with posterior predictive median (purple line) and credible intervals. Middle panel shows the estimated time-varying reproduction number Rt with uncertainty quantification. Bottom panel shows the discretised serial interval used in the Renewal model for Example 1.](examples/example1/fig2.png){#fig-example1-results}

*Full code and additional diagnostics (e.g. prior predictive checks, parameter posteriors) are available in the supplement and in `examples/example1/example-1.qmd`.*

## Example 2: Recreating EpiNow2 configuration {#sec-example2}

<!-- Reference: https://epiforecasts.io/EpiNow2/ -->

This case study recreates a representative EpiNow2 configuration, demonstrating how our compositional approach can represent a complex inference and forecasting workflow.

- Describe modelling ideas in @epinow2
  - Renewal based modelling with generation intervals  
  - Delayed observations of count time series (e.g. cases)
  - Negative binomial link with modifiers (e.g. day of week effects)
  - Focus on core functionality already implemented
- Describe compositional model that recreates this model
- Figure 3: Based on existing EpiNow2 replication work
  - **Panel ABC**: Recreate getting started first three panel plot https://epiforecasts.io/EpiNow2/articles/EpiNow2.html

## Example 3: Recreating Chatzilena et al. {#sec-example3}

<!-- Reference: https://www.sciencedirect.com/science/article/pii/S1755436519300325 -->
<!-- Implementation: https://cdcgov.github.io/Rt-without-renewal/stable/showcase/replications/chatzilena-2019/ -->

- Describe modelling ideas in @chatzilena2019contemporary
  - SIR model for classic influenza data set.
  - Poisson observations with fixed latent observation rate.
  - Conditionally Poisson observations with a latent observation rate (e.g. stochastic SIR model)
- Describe compositional model that recreates this model
- Figure 4: 
  - **Panel A**: Posterior predictive: cases using deterministic SIR model
  - **Panel B**: Posterior predictive: cases using stochastic SIR model

# Discussion {#sec-discussion}

## Demonstrated benefits of compositional modelling

- Talk about how this has demonstrated the potential of compositional approaches to epidemiological modelling 
  - Facilitated model comparison by isolating individual components.
  - Enabled rapid development with new model components.
  - Improve transparency: The compositional structure makes modelling assumptions explicit

## Implications for epidemiological practice

- How this approach addresses the limitations identified in the introduction
- Benefits for outbreak response and real-time surveillance
- Potential for improving reproducibility and transparency in epidemiological modelling

## Limitations and challenges

- Current limitations of the compositional approach
- Computational considerations
- Learning curve and adoption challenges

## Future directions

Several avenues for future development emerge from this work:

- **Expanded component library**: Development of additional components covering specialized epidemiological scenarios
- **Automated model selection**: Tools for systematically exploring component combinations
- **Performance optimization**: Techniques for efficient inference in complex composed models
- **Integration with existing tools**: Bridges to popular epidemiological modelling packages

# Conclusions {#sec-conclusions}

## Software availability

All code and data for reproducing the analyses in this paper are available at: https://github.com/EpiAware/PrototypeCompositionalProbablisticInfectiousDiseaseModelling. The compositional modelling framework is implemented as an open-source Julia package [`EpiAware`](https://github.com/seabbs/Rt-without-renewal).

# References {.unnumbered}

:::{#refs}
:::

# Appendix: Technical details {.unnumbered}

## Component interface specifications

<!-- TODO: Detailed API documentation -->

## Performance benchmarks

<!-- TODO: Computational performance comparisons -->
