---
title: "Contemporary Statistical Inference for Infectious Disease Models using Differential Equations"
format: html
---

# Contemporary statistical inference for infectious disease models {#sec-example3}

In _Contemporary Statistical Inference for Infectious Disease Models using Stan_ Chatzilena _et al_ @chatzilena2019contemporary showcase using the stan PPL @carpenter2017stan for infectious disease models, including differential equation based models.
Chatzilena _et al_ use stan's in-built ordinary differential equation (ODE) solvers to infer epidemic trajectories from observed case counts under the assumption that the latent infection dynamics follow a susceptible-infected-removed (SIR) transmission model @kermack1927contribution; the prototypical compartmental model of transmission dynamics @keeling2008modeling.
They demonstrate epidemic inference with, and without, temporal modification to the ascertainment rate of latent infecteds.

We recreate the ODE based examples from Chatzilena _et al_ by introducing the SIR model as an alternative infection generating process to the renewal model used in the previous case studies and composing this with temporal effects on ascertainment using an autoregressive latent process.
Unlike in stan, we had no requirement to encode a bespoke differential equation solver in our prototype - our prototype integrates with high-quality existing solver libraries from the SciML ecosystem @rackauckas2017differentialequations.

## Data {#sec-data-cs3}

The analysis uses data from an influenza outbreak in an English boarding school, reported in the British Medical Journal in 1978.
We accessed this data using the R package `outbreaks` @jombart2020outbreaks.

```{julia}
using Chain, CSV, DataFramesMeta, Dates
N = 763
datapath = "data/influenza_england_1978_school.csv"
england_data = @chain datapath begin
    CSV.read(DataFrame)
    @transform(:ts = :date - minimum(:date))
    @transform(@byrow :ts = Dates.value(:ts) + 1.0)
    (y_t = _.in_bed, dates = _.date, ts = _.ts)
end
```

### Model

Our model introduces, and composes, new models for generating infections from the solution to an ODE and autoregressive time-varying ascertainment rate of latent infections.
We will start with a simpler observation model, and reusing the infection generating process, then move on to demonstrate time-varying ascertainment.

The mathematical description of the model is:

$$
\begin{align}
\beta, \gamma, I(0), \kappa_0, \phi, \sigma &\sim \pi(\cdot)\\
r_{SI}(t) &= \beta S(t) \frac{I(t)}{N} , ~~ \text{(Infection rate)},\\
r_{IR}(t) &= \gamma I(t), ~~ \text{(Recovery rate)},\\
\frac{dS}{dt} &= -r_{SI}(t), \\
\frac{dI}{dt} &= r_{SI}(t) - r_{IR}(t), \\
\frac{dR}{dt} &= r_{IR}(t),\\
\epsilon_t &\sim \text{Normal}(0, \sigma^2),~ t= 1, 2, \dots ~~ \text{(Observation innovations)}, \\
\kappa_{t} &= \phi \kappa_{t-1} + \epsilon_t, ~~ \text{(Ascertainment process)}, \\
\lambda_t &= I(t)\exp(\kappa_t), ~~ \text{(Expected observations)}, \\ 
Y_t &\sim \text{Poisson}(\lambda_t), ~~ \text{(Observation link)}.  \\
\end{align}
$$

Here we are connecting a continous time model, where we index continuously evolving variables using **(t)**, to daily incrementing processes which we index with a subscript $t$.
The population variables $S(t)$, $I(t)$, and $R(t)$ represent susceptible, infected, and recovered individuals at time $t$.
The transmission rate $\beta$ governs infection spread, whilst the recovery rate $\gamma$ determines infectious period duration.
The basic reproduction number $R_0 = \beta/\gamma$ characterises transmission potential, which is assumed to be constant in time in this model.
All individuals are assumed to be either susceptible or infected the beginning of the outbreak, therefore, only $I(0)$ is needed to define the initial conditions for the outbreak.
The log-scale ascertainment rate  is represented as an autoregressive AR(1) process $\kappa_t$ on daily increments, with a damping $\phi$ parameter, initial state $\kappa_0$ and innovation standard deviation $\sigma$.
$\pi$ represents the priors over each parameter.

#### Latent Models

Chatzilena _et al_ parameterise the autoregressive model for log-scale ascertainment as a time discretised Ornstein-Uhlenbeck process, which can be identified with an AR(1) process.
Taking care to convert priors appropriately we reuse the AR(1) process **...Complete when merged into full document...**

```{julia}
using Distributions, EpiAware
ascert_ar = AR(
    damp_priors = [HalfNormal(0.005)],
    init_priors = [Normal(0, 0.001)],
    ϵ_t = HierarchicalNormal(std_prior = HalfNormal(0.02))
)
display(ascert_ar)
```

The SIR model parameters are static during the outbreak, these are generated directly with the initial fraction of infecteds $I(0) / N$,

```{julia}
sir_params = SIRParams(
    tspan = (0., england_data.ts[end]),   # For ODEProblem constructor
    infectiousness = LogNormal(0.0, 1.0),  # beta prior
    recovery_rate = Gamma(0.004, 1 / 0.002), # gamma prior
    initial_prop_infected = Beta(0.5, 0.5)  # I(0) prior
)
display(sir_params)
```


#### Infection Generating Process

We build the probabilistic SIR model as our infection generating process, by composing the probabilistic ODE model generator with solver details. 
The SIR parameter model (`sir_params`) defines the underlying differential equation model and priors.
The SIR model in our modelling DSL is specified in population density form, therefore, as well as specifying which solution index corresponds to the infecteds, we rescale by the population size $N$.
We also make a `softplus` transformation which stabilises inference when sampling very low values of infected at some time point.


```{julia}
using LogExpFunctions
sir_process = ODEProcess(
    params = sir_params,                                                 # Underlying ODE and priors
    sol2infs = sol -> softplus.(N .* sol[2, :]),                         # Link model
    solver_options = Dict(:verbose => false, :saveat => england_data.ts) # Solver options
)
display(sir_process)
```

This specialises the standard SciML compositional approach: problem definition composed with solution method @rackauckas2017differentialequations, to randomly generated SIR models composed with their solver and a link to latent infections.

#### Observation Model

The observation model is built by first instantiating a Poisson link model.

```{julia}
pois = PoissonError()
display(pois)
```

We then build on the Poisson link by layering the log-scale ascertainment process.

```{julia}
varying_ascertainment = Ascertainment(
    model = pois,
    latent_model = ascert_ar,
    # latent_prefix = mdl_prefix
)
display(varying_ascertainment)
```

The `Ascertainment` struct defines the temporal modifications to the latent infections by first applying multiplicative variation defined by the log-scale ascertainment process, and then linking to the count data.

### Fitting to Data

Chatzilena _et al_ use two different observation models to link the SIR model to the boarding school influenza data.

1. **Deterministic model**. This uses a direct Poisson link for observations; that is defined by the `pois` object, or equivalently by conditioning on $\kappa_t = 0$ for each $t$.
2. **Stochastic model**. This uses the full mathematical model for observations; that is defined by the `varying_ascertainment` object.

#### Deterministic Model

**NOT NEEDED WHEN MERGED IN**
```{julia}
using ReverseDiff, Turing
inference_method = EpiMethod(
    pre_sampler_steps = [ManyPathfinder(nruns = 5, maxiters = 100)],
    sampler = NUTSampler(
        target_acceptance = 0.9,
        adtype = AutoReverseDiff(compile = true),
        ndraws = 1000,
        nchains = 4,
        mcmc_parallel = MCMCThreads(),
        nadapts = 1000)
)
```

We compose the modelling subcomponents into one `EpiProblem` model

```{julia}
tspan = (1, length(england_data.y_t))
deterministic_sir = EpiProblem(epi_model=sir_process,
    latent_model=Null(),
    observation_model=pois,
    tspan=tspan)
```

The `EpiProblem` uses the SIR process with straight Poisson link to the data.
Unlike in the other examples, the SIR process does not require a latent time-varying model for parameters and so that subcomponent is left as `Null`.

We construct a Turing model using `generate_epiaware`, 

```{julia}
deterministic_sir_mdl = generate_epiaware(deterministic_sir, england_data)
```

We reuse the same `inference_method` defined in @sec-example1, showcasing how our inference setup can be applied across different model compositions. **Will be true when merged**

The only extra step in inference compared to previous examples is to let the `SciMLSensitivity` package become available to make reverse-mode automatic differentiation through the ODE solution available.

```{julia}
using SciMLSensitivity
deterministic_sir_results = apply_method(deterministic_sir_mdl,
    inference_method,
    england_data
)
summarystats(deterministic_sir_results.samples)
```

#### Stochastic Model

```{julia}
# prior_chn = sample(deterministic_uncond_mdl, Prior(), 2000)
# gens = generated_quantities(deterministic_uncond_mdl, prior_chn)
```

```{julia}
#| echo: false
# function plot_predYt(data, gens; title::String, ylabel::String)
#     fig = Figure()
#     ga = fig[1, 1:2] = GridLayout()

#     ax = Axis(ga[1, 1];
#         title = title,
#         xticks = (data.ts[1:3:end], data.date[1:3:end] .|> string),
#         ylabel = ylabel
#     )
#     pred_Yt = mapreduce(hcat, gens) do gen
#         gen.generated_y_t
#     end |> X -> mapreduce(vcat, eachrow(X)) do row
#         quantile(row, [0.5, 0.025, 0.975, 0.1, 0.9, 0.25, 0.75])'
#     end

#     lines!(ax, data.ts, pred_Yt[:, 1]; linewidth = 3, color = :green, label = "Median")
#     band!(ax, data.ts, pred_Yt[:, 2], pred_Yt[:, 3], color = (:green, 0.2), label = "95% CI")
#     band!(ax, data.ts, pred_Yt[:, 4], pred_Yt[:, 5], color = (:green, 0.4), label = "80% CI")
#     band!(ax, data.ts, pred_Yt[:, 6], pred_Yt[:, 7], color = (:green, 0.6), label = "50% CI")
#     scatter!(ax, data.in_bed, label = "data")
#     leg = Legend(ga[1, 2], ax; framevisible = false)
#     hidespines!(ax)

#     fig
# end
```

To define the full stochastic model, we reuse the `EpiProblem` from before with the time-varying ascertainment subcomponent replacing the direct Poisson link subcomponent.

```{julia}
using Accessors
stochastic_sir = @set deterministic_sir.observation_model = varying_ascertainment
```

This in turn constructs the corresponding Turing model.

```{julia}
stochastic_sir_mdl = generate_epiaware(stochastic_sir, england_data)
```

And we can apply the same inference method.

```{julia}
stochastic_sir_results = apply_method(stochastic_sir_mdl,
    inference_method,
    england_data
)
summarystats(stochastic_sir_results.samples)
```


```{julia}
#| output: true
#| echo: false
#| label: fig-figure4
#| fig-cap: "Model components and posterior analysis for @sec-example2. (A) Prior samples from the piecewise constant by week ARIMA(2,1,1) latent process for log $R_t$ over 50 days, showing non-stationary reproductive number trajectories that are constant within each week. (B) Prior samples from the renewal model conditional on a fixed $R_t$ trajectory. (C) Prior samples from the composite observation model including incubation period, reporting delays and day-of-week effects around a latent infection curve. (D) Comparison of the continuous incubation period (green line) and reporting delay (blue line) distributions with the combined discretised delay pmf (bars). (E) Posterior predictive distribution for daily cases, with median (purple line) and 50% (dark ribbon) and 95% (light ribbon) credible intervals compared to observed data (black points). (F) Posterior predictive distribution for time-varying $R_t$ on a log scale, with median (green line) and 50% (dark ribbon) and 95% (light ribbon) credible intervals."
figure4 = let
    qs = [0.025, 0.25, 0.5, 0.75, 0.975]
    n_samples = 100
    t_ticks = @chain italy_training_data begin
        _.dates
        string.(_)
    end
    ts = dates_to_times(italy_training_data.dates)

    posterior_gens = posterior_gens_for_plot(epinow2_results, length(italy_training_data.y_t);
        epi_prob=epinow2)

    latent_infections = [500 * (1 + cospi(2 * t / 30.0)) for t = 1:(7*10)]
    log_scale_dow_effect = [1.0; zeros(6)]
    obs_mdl = generate_observations(delay_dayofweek_negbin, missing, latent_infections) |
              (var"DayofWeek.ϵ_t"=log_scale_dow_effect,)

    fig = Figure(size=(1200, 1000))
    ax11 = Axis(fig[1, 1];
        yscale=log10,
        ylabel="Time varying Rₜ"
    )
    ax12 = Axis(fig[1, 2];
        ylabel="Latent infections"
    )
    ax13 = Axis(fig[1, 3];
        ylabel="Observed cases"
    )
    ax21 = Axis(fig[2, 1];
        xticks=0:5:20,
        xlabel="Days"
    )
    ax22 = Axis(fig[2, 2];
        ylabel="Daily cases",
        xticks=(ts[1:14:end], t_ticks[1:14:end])
    )
    ax23 = Axis(fig[2, 3];
        yscale=log10,
        ylabel="Time varying Rₜ",
        xticks=(ts[1:14:end], t_ticks[1:14:end])
    )

    arima_sample_plot!(ax11, weekly_arima211_mdl; n_samples)
    plot_latent_infections!(ax12, renewal_mdl; n_samples)
    delay_dow_sample_plot!(ax13, obs_mdl, latent_infections; n_samples)

    # Extract delay PMFs
    incubation_pmf = incubation_dayofweek_negbin.rev_pmf[end:-1:1]
    # Create a standalone reporting delay to get its PMF
    reporting_delay_only = LatentDelay(negbin, reporting_distribution)
    reporting_pmf = reporting_delay_only.rev_pmf[end:-1:1]

    barplot!(ax21, 0:(length(incubation_pmf)-1), incubation_pmf;
        label="Incubation period", alpha=0.6, color=:green)
    lines!(ax21, 0:0.1:20, x -> pdf(incubation_distribution, x);
        color=:green, linewidth=2)
    barplot!(ax21, 0:(length(reporting_pmf)-1), reporting_pmf;
        label="Reporting delay", alpha=0.6, color=:blue)
    lines!(ax21, 0:0.1:20, x -> pdf(reporting_distribution, x);
        color=:blue, linewidth=2)
    ax21.ytickformat = values -> [string(round(v, digits=4)) for v in values]
    axislegend(ax21)

    post_predictive_yt!(ax22, italy_training_data, posterior_gens; qs)
    post_predictive_Rt!(ax23, italy_training_data, posterior_gens; qs)

    # Format y-axis labels to avoid scientific notation
    ax11.ytickformat = values -> [string(round(v, digits=2)) for v in values]
    ax12.ytickformat = values -> [string(round(Int, v)) for v in values]
    ax13.ytickformat = values -> [string(round(Int, v)) for v in values]
    ax22.ytickformat = values -> [string(round(Int, v)) for v in values]
    ax23.ytickformat = values -> [string(round(v, digits=2)) for v in values]

    # Add panel labels
    for (label, layout) in zip(["A", "B", "C", "D", "E", "F"],
        [fig[1, 1], fig[1, 2], fig[1, 3], fig[2, 1], fig[2, 2], fig[2, 3]])
        Label(layout[1, 1, TopLeft()], label,
            fontsize=18,
            font=:bold,
            padding=(0, 5, 5, 0),
            halign=:right)
    end

    fig
end

figure3
```
